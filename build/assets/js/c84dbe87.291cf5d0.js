"use strict";(self.webpackChunkcodeprime=self.webpackChunkcodeprime||[]).push([[1032],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>d});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var i=a.createContext({}),c=function(e){var t=a.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(r),d=n,h=p["".concat(i,".").concat(d)]||p[d]||m[d]||o;return r?a.createElement(h,l(l({ref:t},u),{},{components:r})):a.createElement(h,l({ref:t},u))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,l=new Array(o);l[0]=p;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:n,l[1]=s;for(var c=2;c<o;c++)l[c]=r[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5162:(e,t,r)=>{r.d(t,{Z:()=>l});var a=r(7294),n=r(4334);const o="tabItem_Ymn6";function l(e){let{children:t,hidden:r,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,n.Z)(o,l),hidden:r},t)}},5488:(e,t,r)=>{r.d(t,{Z:()=>d});var a=r(3117),n=r(7294),o=r(4334),l=r(2389),s=r(7392),i=r(7094),c=r(2466);const u="tabList__CuJ",m="tabItem_LNqP";function p(e){var t,r;const{lazy:l,block:p,defaultValue:d,values:h,groupId:b,className:k}=e,f=n.Children.map(e.children,(e=>{if((0,n.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),y=null!=h?h:f.map((e=>{let{props:{value:t,label:r,attributes:a}}=e;return{value:t,label:r,attributes:a}})),v=(0,s.l)(y,((e,t)=>e.value===t.value));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const g=null===d?d:null!=(t=null!=d?d:null==(r=f.find((e=>e.props.default)))?void 0:r.props.value)?t:f[0].props.value;if(null!==g&&!y.some((e=>e.value===g)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+g+'" but none of its children has the corresponding value. Available values are: '+y.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:N,setTabGroupChoices:T}=(0,i.U)(),[w,x]=(0,n.useState)(g),S=[],{blockElementScrollPositionUntilNextRender:O}=(0,c.o5)();if(null!=b){const e=N[b];null!=e&&e!==w&&y.some((t=>t.value===e))&&x(e)}const P=e=>{const t=e.currentTarget,r=S.indexOf(t),a=y[r].value;a!==w&&(O(t),x(a),null!=b&&T(b,String(a)))},E=e=>{var t;let r=null;switch(e.key){case"ArrowRight":{var a;const t=S.indexOf(e.currentTarget)+1;r=null!=(a=S[t])?a:S[0];break}case"ArrowLeft":{var n;const t=S.indexOf(e.currentTarget)-1;r=null!=(n=S[t])?n:S[S.length-1];break}}null==(t=r)||t.focus()};return n.createElement("div",{className:(0,o.Z)("tabs-container",u)},n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":p},k)},y.map((e=>{let{value:t,label:r,attributes:l}=e;return n.createElement("li",(0,a.Z)({role:"tab",tabIndex:w===t?0:-1,"aria-selected":w===t,key:t,ref:e=>S.push(e),onKeyDown:E,onFocus:P,onClick:P},l,{className:(0,o.Z)("tabs__item",m,null==l?void 0:l.className,{"tabs__item--active":w===t})}),null!=r?r:t)}))),l?(0,n.cloneElement)(f.filter((e=>e.props.value===w))[0],{className:"margin-top--md"}):n.createElement("div",{className:"margin-top--md"},f.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==w})))))}function d(e){const t=(0,l.Z)();return n.createElement(p,(0,a.Z)({key:String(t)},e))}},4782:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>m});var a=r(3117),n=(r(7294),r(3905)),o=r(5488),l=r(5162);const s={sidebar_position:137,tags:["Stack","Tree","Design","Binary Search Tree","Binary Tree","Iterator"]},i="Binary Search Tree Iterator",c={unversionedId:"codes/binary-search-tree-iterator",id:"codes/binary-search-tree-iterator",title:"Binary Search Tree Iterator",description:"Problem",source:"@site/docs/codes/binary-search-tree-iterator.md",sourceDirName:"codes",slug:"/codes/binary-search-tree-iterator",permalink:"/CodePrime/docs/codes/binary-search-tree-iterator",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/codes/binary-search-tree-iterator.md",tags:[{label:"Stack",permalink:"/CodePrime/docs/tags/stack"},{label:"Tree",permalink:"/CodePrime/docs/tags/tree"},{label:"Design",permalink:"/CodePrime/docs/tags/design"},{label:"Binary Search Tree",permalink:"/CodePrime/docs/tags/binary-search-tree"},{label:"Binary Tree",permalink:"/CodePrime/docs/tags/binary-tree"},{label:"Iterator",permalink:"/CodePrime/docs/tags/iterator"}],version:"current",sidebarPosition:137,frontMatter:{sidebar_position:137,tags:["Stack","Tree","Design","Binary Search Tree","Binary Tree","Iterator"]},sidebar:"Leetcode",previous:{title:"Maximum Sum BST in Binary Tree",permalink:"/CodePrime/docs/codes/maximum-sum-bst-in-binary-tree"},next:{title:"Ceil from BST",permalink:"/CodePrime/docs/codes/ceil-from-bst"}},u={},m=[{value:"Problem",id:"problem",level:2},{value:"Solution Approach",id:"solution-approach",level:2}],p={toc:m};function d(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"binary-search-tree-iterator"},"Binary Search Tree Iterator"),(0,n.kt)("h2",{id:"problem"},(0,n.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/binary-search-tree-iterator/"},"Problem")),(0,n.kt)("p",null,"Implement the ",(0,n.kt)("code",null,"BSTIterator")," class that represents an iterator over the ",(0,n.kt)("strong",null,(0,n.kt)("a",{href:"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)",target:"_blank"},"in-order traversal"))," of a binary search tree (BST):"),(0,n.kt)("ul",null,(0,n.kt)("li",null,(0,n.kt)("code",null,"BSTIterator(TreeNode root)")," Initializes an object of the ",(0,n.kt)("code",null,"BSTIterator")," class. The ",(0,n.kt)("code",null,"root")," of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST."),(0,n.kt)("li",null,(0,n.kt)("code",null,"boolean hasNext()")," Returns ",(0,n.kt)("code",null,"true")," if there exists a number in the traversal to the right of the pointer, otherwise returns ",(0,n.kt)("code",null,"false"),"."),(0,n.kt)("li",null,(0,n.kt)("code",null,"int next()")," Moves the pointer to the right, then returns the number at the pointer.")),(0,n.kt)("p",null,"Notice that by initializing the pointer to a non-existent smallest number, the first call to ",(0,n.kt)("code",null,"next()")," will return the smallest element in the BST."),(0,n.kt)("p",null,"You may assume that ",(0,n.kt)("code",null,"next()")," calls will always be valid. That is, there will be at least a next number in the in-order traversal when ",(0,n.kt)("code",null,"next()")," is called."),(0,n.kt)("h2",{id:"solution-approach"},"Solution Approach"),(0,n.kt)("p",null,"Expected Time complexity: ",(0,n.kt)("span",{parentName:"p",className:"math math-inline"},(0,n.kt)("span",{parentName:"span",className:"katex"},(0,n.kt)("span",{parentName:"span",className:"katex-mathml"},(0,n.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,n.kt)("semantics",{parentName:"math"},(0,n.kt)("mrow",{parentName:"semantics"},(0,n.kt)("mi",{parentName:"mrow"},"O"),(0,n.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,n.kt)("mi",{parentName:"mrow"},"n"),(0,n.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,n.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,n.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,n.kt)("span",{parentName:"span",className:"base"},(0,n.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,n.kt)("span",{parentName:"span",className:"mopen"},"("),(0,n.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,n.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,n.kt)("details",null,(0,n.kt)("summary",null,"Click - to see solution code"),(0,n.kt)(o.Z,{mdxType:"Tabs"},(0,n.kt)(l.Z,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"class BSTIterator {\n    stack<TreeNode *> myStack;\n\n   public:\n    BSTIterator(TreeNode *root) { pushAll(root); }\n\n    bool hasNext() { return !myStack.empty(); }\n\n    int next() {\n        TreeNode *tmpNode = myStack.top();\n        myStack.pop();\n        pushAll(tmpNode->right);\n        return tmpNode->val;\n    }\n\n   private:\n    void pushAll(TreeNode *node) {\n        for (; node != NULL; myStack.push(node), node = node->left)\n            ;\n    }\n};\n\n"))))))}d.isMDXComponent=!0}}]);