"use strict";(self.webpackChunkcodeprime=self.webpackChunkcodeprime||[]).push([[7038],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,h=m["".concat(i,".").concat(d)]||m[d]||p[d]||l;return n?a.createElement(h,s(s({ref:t},u),{},{components:n})):a.createElement(h,s({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=m;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<l;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8215:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294);const r=function(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},9877:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(7462),r=n(7294),l=n(2389),s=n(5773),o=n(6010);const i="tabItem_LplD";function c(e){var t,n,l;const{lazy:c,block:u,defaultValue:p,values:m,groupId:d,className:h}=e,f=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),b=null!=m?m:f.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),k=(0,s.lx)(b,((e,t)=>e.value===t.value));if(k.length>0)throw new Error('Docusaurus error: Duplicate values "'+k.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const v=null===p?p:null!=(t=null!=p?p:null==(n=f.find((e=>e.props.default)))?void 0:n.props.value)?t:null==(l=f[0])?void 0:l.props.value;if(null!==v&&!b.some((e=>e.value===v)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+b.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:g,setTabGroupChoices:N}=(0,s.UB)(),[y,w]=(0,r.useState)(v),L=[],{blockElementScrollPositionUntilNextRender:x}=(0,s.o5)();if(null!=d){const e=g[d];null!=e&&e!==y&&b.some((t=>t.value===e))&&w(e)}const O=e=>{const t=e.currentTarget,n=L.indexOf(t),a=b[n].value;a!==y&&(x(t),w(a),null!=d&&N(d,a))},T=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=L.indexOf(e.currentTarget)+1;n=L[t]||L[0];break}case"ArrowLeft":{const t=L.indexOf(e.currentTarget)-1;n=L[t]||L[L.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":u},h)},b.map((e=>{let{value:t,label:n,attributes:l}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:y===t?0:-1,"aria-selected":y===t,key:t,ref:e=>L.push(e),onKeyDown:T,onFocus:O,onClick:O},l,{className:(0,o.Z)("tabs__item",i,null==l?void 0:l.className,{"tabs__item--active":y===t})}),null!=n?n:t)}))),c?(0,r.cloneElement)(f.filter((e=>e.props.value===y))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},f.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==y})))))}function u(e){const t=(0,l.Z)();return r.createElement(c,(0,a.Z)({key:String(t)},e))}},2521:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>o,contentTitle:()=>i,metadata:()=>c,toc:()=>u,default:()=>m});var a=n(7462),r=(n(7294),n(3905)),l=n(9877),s=n(8215);const o={sidebar_position:6,tags:["Linked List","Recursion"]},i="Merge Two Sorted Lists",c={unversionedId:"codes/merge-two-sorted-lists",id:"codes/merge-two-sorted-lists",title:"Merge Two Sorted Lists",description:"Problem",source:"@site/docs/codes/merge-two-sorted-lists.md",sourceDirName:"codes",slug:"/codes/merge-two-sorted-lists",permalink:"/CodePrime/docs/codes/merge-two-sorted-lists",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/codes/merge-two-sorted-lists.md",tags:[{label:"Linked List",permalink:"/CodePrime/docs/tags/linked-list"},{label:"Recursion",permalink:"/CodePrime/docs/tags/recursion"}],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,tags:["Linked List","Recursion"]}},u=[{value:"Problem",id:"problem",children:[],level:2},{value:"Solution Approach",id:"solution-approach",children:[],level:2}],p={toc:u};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"merge-two-sorted-lists"},"Merge Two Sorted Lists"),(0,r.kt)("h2",{id:"problem"},(0,r.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/merge-two-sorted-lists/"},"Problem")),(0,r.kt)("p",null,"You are given the heads of two sorted linked lists ",(0,r.kt)("code",null,"list1")," and ",(0,r.kt)("code",null,"list2"),"."),(0,r.kt)("p",null,"Merge the two lists in a one ",(0,r.kt)("strong",null,"sorted")," list. The list should be made by splicing together the nodes of the first two lists."),(0,r.kt)("p",null,"Return ",(0,r.kt)("em",null,"the head of the merged linked list"),"."),(0,r.kt)("h2",{id:"solution-approach"},"Solution Approach"),(0,r.kt)("p",null,"Make a new LinkedList and keep adding the smaller of the two head(list1, list2) nodes at the tail of the new linked list and return the head node of the new Linked list."),(0,r.kt)("p",null,"Expected Time complexity: ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Click - to see solution code"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n\n        // if any of the linkedlist is NULL return the other\n        if (list1 == NULL) return list2;    \n        if (list2 == NULL) return list1;\n\n        if (list1->val > list2->val) swap(list1, list2);\n        ListNode *head;\n        head = (ListNode*)malloc(sizeof(ListNode*));\n        head = list1;\n\n        while (list1->next != NULL && list2 != NULL) {\n            if (list1->next->val <= list2->val) {\n                list1 = list1->next;\n                continue;\n            }\n            ListNode *temp;\n            temp = (ListNode*)malloc(sizeof(ListNode*));\n            temp = list2;\n            list2 = list2->next;\n            temp->next = list1->next;\n            list1->next = temp;\n            list1 = list1->next;\n        }\n        if (list2 != NULL) {\n            list1->next = list2;\n        }\n        return head;\n    }\n};\n"))))))}m.isMDXComponent=!0}}]);