"use strict";(self.webpackChunkcodeprime=self.webpackChunkcodeprime||[]).push([[5880],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,f=u["".concat(s,".").concat(m)]||u[m]||d[m]||l;return n?a.createElement(f,o(o({ref:t},c),{},{components:n})):a.createElement(f,o({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var p=2;p<l;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8215:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294);const r=function(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},9877:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(7462),r=n(7294),l=n(2389),o=n(5773),i=n(6010);const s="tabItem_LplD";function p(e){var t,n,l;const{lazy:p,block:c,defaultValue:d,values:u,groupId:m,className:f}=e,h=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),k=null!=u?u:h.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),y=(0,o.lx)(k,((e,t)=>e.value===t.value));if(y.length>0)throw new Error('Docusaurus error: Duplicate values "'+y.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const v=null===d?d:null!=(t=null!=d?d:null==(n=h.find((e=>e.props.default)))?void 0:n.props.value)?t:null==(l=h[0])?void 0:l.props.value;if(null!==v&&!k.some((e=>e.value===v)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+k.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:b,setTabGroupChoices:N}=(0,o.UB)(),[g,w]=(0,r.useState)(v),x=[],{blockElementScrollPositionUntilNextRender:O}=(0,o.o5)();if(null!=m){const e=b[m];null!=e&&e!==g&&k.some((t=>t.value===e))&&w(e)}const q=e=>{const t=e.currentTarget,n=x.indexOf(t),a=k[n].value;a!==g&&(O(t),w(a),null!=m&&N(m,a))},T=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=x.indexOf(e.currentTarget)+1;n=x[t]||x[0];break}case"ArrowLeft":{const t=x.indexOf(e.currentTarget)-1;n=x[t]||x[x.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":c},f)},k.map((e=>{let{value:t,label:n,attributes:l}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:g===t?0:-1,"aria-selected":g===t,key:t,ref:e=>x.push(e),onKeyDown:T,onFocus:q,onClick:q},l,{className:(0,i.Z)("tabs__item",s,null==l?void 0:l.className,{"tabs__item--active":g===t})}),null!=n?n:t)}))),p?(0,r.cloneElement)(h.filter((e=>e.props.value===g))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},h.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==g})))))}function c(e){const t=(0,l.Z)();return r.createElement(p,(0,a.Z)({key:String(t)},e))}},6304:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>i,contentTitle:()=>s,metadata:()=>p,toc:()=>c,default:()=>u});var a=n(7462),r=(n(7294),n(3905)),l=n(9877),o=n(8215);const i={sidebar_position:84,tags:["Hash Table","Linked List","Design","Doubly-Linked List"]},s="LFU Cache",p={unversionedId:"codes/lfu-cache",id:"codes/lfu-cache",title:"LFU Cache",description:"Problem",source:"@site/docs/codes/lfu-cache.md",sourceDirName:"codes",slug:"/codes/lfu-cache",permalink:"/CodePrime/docs/codes/lfu-cache",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/codes/lfu-cache.md",tags:[{label:"Hash Table",permalink:"/CodePrime/docs/tags/hash-table"},{label:"Linked List",permalink:"/CodePrime/docs/tags/linked-list"},{label:"Design",permalink:"/CodePrime/docs/tags/design"},{label:"Doubly-Linked List",permalink:"/CodePrime/docs/tags/doubly-linked-list"}],version:"current",sidebarPosition:84,frontMatter:{sidebar_position:84,tags:["Hash Table","Linked List","Design","Doubly-Linked List"]},sidebar:"main",previous:{title:"Rotting Oranges",permalink:"/CodePrime/docs/codes/rotting-oranges"},next:{title:"Online Stock Span",permalink:"/CodePrime/docs/codes/online-stock-span"}},c=[{value:"Problem",id:"problem",children:[],level:2},{value:"Solution Approach",id:"solution-approach",children:[],level:2}],d={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lfu-cache"},"LFU Cache"),(0,r.kt)("h2",{id:"problem"},(0,r.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/lfu-cache/"},"Problem")),(0,r.kt)("p",null,"Design and implement a data structure for a ",(0,r.kt)("a",{href:"https://en.wikipedia.org/wiki/Least_frequently_used",target:"_blank"},"Least Frequently Used (LFU)")," cache."),(0,r.kt)("p",null,"Implement the ",(0,r.kt)("code",null,"LFUCache")," class:"),(0,r.kt)("ul",null,(0,r.kt)("li",null,(0,r.kt)("code",null,"LFUCache(int capacity)")," Initializes the object with the ",(0,r.kt)("code",null,"capacity")," of the data structure."),(0,r.kt)("li",null,(0,r.kt)("code",null,"int get(int key)")," Gets the value of the ",(0,r.kt)("code",null,"key")," if the ",(0,r.kt)("code",null,"key")," exists in the cache. Otherwise, returns ",(0,r.kt)("code",null,"-1"),"."),(0,r.kt)("li",null,(0,r.kt)("code",null,"void put(int key, int value)")," Update the value of the ",(0,r.kt)("code",null,"key")," if present, or inserts the ",(0,r.kt)("code",null,"key")," if not already present. When the cache reaches its ",(0,r.kt)("code",null,"capacity"),", it should invalidate and remove the ",(0,r.kt)("strong",null,"least frequently used")," key before inserting a new item. For this problem, when there is a ",(0,r.kt)("strong",null,"tie")," (i.e., two or more keys with the same frequency), the ",(0,r.kt)("strong",null,"least recently used")," ",(0,r.kt)("code",null,"key")," would be invalidated.")),(0,r.kt)("p",null,"To determine the least frequently used key, a ",(0,r.kt)("strong",null,"use counter")," is maintained for each key in the cache. The key with the smallest ",(0,r.kt)("strong",null,"use counter")," is the least frequently used key."),(0,r.kt)("p",null,"When a key is first inserted into the cache, its ",(0,r.kt)("strong",null,"use counter")," is set to ",(0,r.kt)("code",null,"1")," (due to the ",(0,r.kt)("code",null,"put")," operation). The ",(0,r.kt)("strong",null,"use counter")," for a key in the cache is incremented either a ",(0,r.kt)("code",null,"get")," or ",(0,r.kt)("code",null,"put")," operation is called on it."),(0,r.kt)("p",null,"The functions\xa0",(0,r.kt)("code",{"data-stringify-type":"code"},"get"),"\xa0and\xa0",(0,r.kt)("code",{"data-stringify-type":"code"},"put"),"\xa0must each run in ",(0,r.kt)("code",null,"O(1)")," average time complexity."),(0,r.kt)("h2",{id:"solution-approach"},"Solution Approach"),(0,r.kt)("p",null,"Expected Time complexity: ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Click - to see solution code"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct Node {\n    int key, value, freq;\n    Node *next;\n    Node *prev;\n    Node(int k, int v, int f) {\n        key = k, value = v, freq = f;\n        next = prev = NULL;\n    }\n};\n\nstruct dlist {\n    Node *head, *tail;\n    int size;\n\n    dlist() {\n        head = new Node(-1, -1, 0);\n        tail = new Node(-1, -1, 0);\n        head->next = tail;\n        tail->prev = head;\n        size = 0;\n    }\n\n    Node *addNode(int k, int v, int f) {\n        size++;\n        Node *newNode = new Node(k, v, f);\n        newNode->next = head->next;\n        head->next->prev = newNode;\n        newNode->prev = head;\n        head->next = newNode;\n        return newNode;\n    }\n\n    void delNode(Node *&node) {\n        size--;\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    int empty() { return size == 0; }\n};\n\nclass LFUCache {\n    int cap, cnt, mf;\n    map<int, Node *> mp;\n    map<int, dlist *> fmap;\n\n   public:\n    LFUCache(int capacity) {\n        cap = capacity;\n        cnt = 0;\n        mf = 0;\n    }\n\n    int get(int key) {\n        if (mp.find(key) == mp.end()) return -1;\n        Node *ptr = mp[key];\n        fmap[ptr->freq]->delNode(ptr);\n        cnt--;\n        if (fmap[ptr->freq]->empty()) {\n            if (mf == ptr->freq) mf = ptr->freq + 1;\n            fmap.erase(ptr->freq);\n        }\n\n        if (fmap.find(ptr->freq + 1) != fmap.end()) {\n            Node *ptrr =\n                fmap[ptr->freq + 1]->addNode(key, ptr->value, ptr->freq + 1);\n            mp[key] = ptrr;\n            cnt++;\n        } else {\n            cnt++;\n            dlist *ptrr = new dlist();\n            fmap[ptr->freq + 1] = ptrr;\n            Node *node =\n                fmap[ptr->freq + 1]->addNode(key, ptr->value, ptr->freq + 1);\n            mp[key] = node;\n        }\n\n        return ptr->value;\n    }\n\n    void put(int key, int value) {\n        if (cap == 0) return;\n        if (mp.find(key) != mp.end()) {\n            Node *ptr = mp[key];\n            fmap[ptr->freq]->delNode(ptr);\n            if (fmap[ptr->freq]->empty()) {\n                if (mf == ptr->freq) mf = ptr->freq + 1;\n                fmap.erase(ptr->freq);\n            }\n            if (fmap.find(ptr->freq + 1) != fmap.end()) {\n                Node *node =\n                    fmap[ptr->freq + 1]->addNode(key, value, ptr->freq + 1);\n                mp[key] = node;\n            } else {\n                dlist *ptrr = new dlist();\n                fmap[ptr->freq + 1] = ptrr;\n                Node *node =\n                    fmap[ptr->freq + 1]->addNode(key, value, ptr->freq + 1);\n                mp[key] = node;\n            }\n            return;\n        }\n\n        if (cnt == cap) {\n            Node *ptr = fmap[mf]->tail->prev;\n            fmap[mf]->delNode(ptr);\n            cnt--;\n            if (fmap[mf]->empty()) {\n                fmap.erase(mf);\n            }\n            mp.erase(ptr->key);\n        }\n\n        mf = 0;\n        if (fmap.find(mf) != fmap.end()) {\n            Node *ptr = fmap[mf]->addNode(key, value, mf);\n            mp[key] = ptr;\n            cnt++;\n            return;\n        }\n\n        cnt++;\n        dlist *ptr = new dlist();\n        fmap[mf] = ptr;\n        Node *node = fmap[mf]->addNode(key, value, mf);\n        mp[key] = node;\n    }\n};\n\n\n"))))))}u.isMDXComponent=!0}}]);